package crud

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strings"
)

// executor defines the common methods between *sql.DB and *sql.Tx.
type executor interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

type Repository[T any] struct {
	db                *sql.DB
	tx                *sql.Tx // Transaction object
	tableName         string
	columns           []string       // List of database column names
	pkColumn          string         // Database column name of the primary key
	pkIsAutoIncrement bool           // Flag if the primary key is an auto-incrementing integer
	scanMap           map[string]int // Map of column name to field index for scanning
	dialect           Dialect
	fields            []fieldInfo // Cached information about struct fields
}

// fieldInfo caches metadata about a struct field.
type fieldInfo struct {
	columnName string
	fieldIndex int
	isPK       bool
}

// getExecutor returns the correct executor (transaction or database connection).
func (r *Repository[T]) getExecutor() executor {
	if r.tx != nil {
		return r.tx
	}
	return r.db
}

// WithTx returns a new repository instance that will run queries within the given transaction.
func (r *Repository[T]) WithTx(tx *sql.Tx) RepositoryInterface[T] {
	// Return a shallow copy of the repository with the transaction set.
	repoCopy := *r
	repoCopy.tx = tx
	return &repoCopy
}

func (r *Repository[T]) Where(args ...any) Option[T] {
	return Where[T](args...)
}

func (r *Repository[T]) OrderBy(column string, direction SortDirection) Option[T] {
	return OrderBy[T](column, direction)
}

func (r *Repository[T]) Limit(limit int) Option[T] {
	return Limit[T](limit)
}

func (r *Repository[T]) Offset(offset int) Option[T] {
	return Offset[T](offset)
}

func (r *Repository[T]) Join(joinClause string) Option[T] {
	return Join[T](joinClause)
}

func (r *Repository[T]) Lock(clause string) Option[T] {
	return Lock[T](clause)
}

func (r *Repository[T]) WhereIn(column string, values ...any) Option[T] {
	return WhereIn[T](column, values...)
}

func (r *Repository[T]) WhereLike(column string, value any) Option[T] {
	return WhereLike[T](column, value)
}

func (r *Repository[T]) WhereSubquery(column, operator, subquery string, args ...any) Option[T] {
	return WhereSubquery[T](column, operator, subquery, args...)
}

func (r *Repository[T]) WithRelation(mapper Relation[T]) Option[T] {
	return WithRelation[T](mapper)
}

// NewRepository creates a new generic repository for the given type T.
// It analyzes the struct T to map its fields to database columns using reflection.
func NewRepository[T any](db *sql.DB, tableName string, dialect Dialect) (RepositoryInterface[T], error) {
	var instance T
	typeOfT := reflect.TypeOf(instance)
	if typeOfT.Kind() != reflect.Struct {
		return nil, fmt.Errorf("generic type T must be a struct, but got %s", typeOfT.Kind())
	}

	repo := &Repository[T]{
		db:        db,
		tableName: tableName,
		scanMap:   make(map[string]int),
		dialect:   dialect,
		fields:    make([]fieldInfo, 0),
	}

	for i := 0; i < typeOfT.NumField(); i++ {
		field := typeOfT.Field(i)
		tag := field.Tag.Get("db")

		if tag == "" || tag == "-" {
			continue
		}

		tagParts := strings.Split(tag, ",")
		columnName := tagParts[0]

		isPK := false
		for _, part := range tagParts[1:] {
			if part == "pk" {
				isPK = true
				if repo.pkColumn != "" {
					return nil, fmt.Errorf("multiple primary key fields defined in %s", typeOfT.Name())
				}
				repo.pkColumn = columnName

				// Check if the PK is an integer type, assume auto-increment
				switch field.Type.Kind() {
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
					reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
					repo.pkIsAutoIncrement = true
				default:
					repo.pkIsAutoIncrement = false
				}
			}
		}

		repo.columns = append(repo.columns, columnName)
		repo.scanMap[columnName] = i
		repo.fields = append(repo.fields, fieldInfo{columnName: columnName, fieldIndex: i, isPK: isPK})
	}

	if len(repo.columns) == 0 {
		return nil, fmt.Errorf("no 'db' tags found in struct %s", typeOfT.Name())
	}
	if repo.pkColumn == "" {
		return nil, fmt.Errorf("no primary key field defined with ',pk' tag in struct %s", typeOfT.Name())
	}

	return repo, nil
}

// Create inserts a new record into the database based on the provided item.
// It returns the newly created item, including any fields auto-generated by the database (like ID or timestamps).
func (r *Repository[T]) Create(ctx context.Context, item T) (T, error) {
	colsToInsert := make([]string, 0, len(r.fields))
	valsToInsert := make([]any, 0, len(r.fields))
	placeholders := make([]string, 0, len(r.fields))

	valOfItem := reflect.ValueOf(item)

	for _, fieldInfo := range r.fields {
		// If the PK is auto-incrementing, don't include it in the insert statement's columns.
		if fieldInfo.isPK && r.pkIsAutoIncrement {
			continue
		}

		colsToInsert = append(colsToInsert, fieldInfo.columnName)
		valsToInsert = append(valsToInsert, valOfItem.Field(fieldInfo.fieldIndex).Interface())
		placeholders = append(placeholders, r.dialect.Placeholder(len(placeholders)+1))
	}

	sqlQuery := r.dialect.InsertSQL(r.tableName, colsToInsert, placeholders)
	e := r.getExecutor()

	// Unified path for PostgreSQL: always use RETURNING to get the final state of the row.
	if _, isPg := r.dialect.(PostgresDialect); isPg {
		sqlQuery += " RETURNING " + strings.Join(r.columns, ", ")
		row := e.QueryRowContext(ctx, sqlQuery, valsToInsert...)
		return r.scanRow(row)
	}

	// Path for other dialects (MySQL, SQLite, etc.)
	res, execErr := e.ExecContext(ctx, sqlQuery, valsToInsert...)
	if execErr != nil {
		var zero T
		return zero, fmt.Errorf("insert failed: %w", execErr)
	}

	// For non-auto-increment PKs, we're done. Return the original item.
	if !r.pkIsAutoIncrement {
		return item, nil
	}

	// For auto-incrementing PKs, fetch the last inserted ID.
	lastID, idErr := res.LastInsertId()
	if idErr != nil {
		var zero T
		return zero, fmt.Errorf("insert successful, but failed to retrieve last insert ID: %w", idErr)
	}

	return r.GetByID(ctx, lastID)
}

// CreateOrUpdate inserts a new record or updates it if it already exists.
func (r *Repository[T]) CreateOrUpdate(ctx context.Context, item T) (T, error) {
	var pkValue any
	var pkIndex int = -1
	vals := make([]any, 0, len(r.fields))

	valOfItem := reflect.ValueOf(item)

	for _, fieldInfo := range r.fields {
		vals = append(vals, valOfItem.Field(fieldInfo.fieldIndex).Interface())
		if fieldInfo.isPK {
			pkValue = valOfItem.Field(fieldInfo.fieldIndex).Interface()
			pkIndex = fieldInfo.fieldIndex
		}
	}

	if pkIndex == -1 {
		var zero T
		return zero, fmt.Errorf("no primary key field found for upsert")
	}

	sqlQuery := r.dialect.UpsertSQL(r.tableName, r.pkColumn, r.columns)
	e := r.getExecutor()

	_, err := e.ExecContext(ctx, sqlQuery, vals...)
	if err != nil {
		var zero T
		return zero, fmt.Errorf("upsert failed: %w", err)
	}

	// After upsert, fetch the final state of the item to ensure we have the correct data.
	return r.GetByID(ctx, pkValue)
}

// GetByID retrieves a single record from the database by its primary key.
// It returns sql.ErrNoRows if no record is found.
func (r *Repository[T]) GetByID(ctx context.Context, id any, opts ...Option[T]) (T, error) {
	qb := &queryBuilder[T]{
		dialect: r.dialect,
	}
	// Apply provided options (e.g., WithLock)
	for _, opt := range opts {
		if err := opt.apply(qb); err != nil {
			var zero T
			return zero, err
		}
	}

	// Add the primary key filter
	qb.whereClauses = append(qb.whereClauses, fmt.Sprintf("%s = %s", r.pkColumn, r.dialect.Placeholder(len(qb.args)+1)))
	qb.args = append(qb.args, id)

	sql := r.dialect.SelectSQL(
		r.tableName, r.columns, "", strings.Join(qb.whereClauses, " AND "), "", qb.lockClause, 0, 0,
	)

	row := r.getExecutor().QueryRowContext(ctx, sql, qb.args...)
	item, err := r.scanRow(row)
	if err != nil {
		return item, err
	}

	// Handle eager loading if there are relations
	if len(qb.relations) > 0 {
		// We need a slice of pointers to pass to handleRelations
		items := []*T{&item}
		if err := r.handleRelations(ctx, qb, items); err != nil {
			return item, err
		}
		return *items[0], nil
	}

	return item, nil
}

// Update modifies an existing record in the database based on the provided item.
// The primary key from the item is used in the WHERE clause.
// It returns the updated item, reflecting any changes made by the database.
func (r *Repository[T]) Update(ctx context.Context, item T) (T, error) {
	var setClauses strings.Builder
	vals := make([]any, 0, len(r.fields))
	var pkValue any

	valOfItem := reflect.ValueOf(item)

	for _, fieldInfo := range r.fields {
		fieldValue := valOfItem.Field(fieldInfo.fieldIndex).Interface()

		if fieldInfo.isPK {
			pkValue = fieldValue
			continue
		}

		if setClauses.Len() > 0 {
			setClauses.WriteString(", ")
		}
		setClauses.WriteString(fmt.Sprintf("%s = %s", fieldInfo.columnName, r.dialect.Placeholder(len(vals)+1)))
		vals = append(vals, fieldValue)
	}

	if pkValue == nil || (reflect.ValueOf(pkValue).Kind() == reflect.Pointer && reflect.ValueOf(pkValue).IsNil()) {
		var zero T
		return zero, fmt.Errorf("primary key value not found in item to update")
	}
	vals = append(vals, pkValue)

	sqlQuery := r.dialect.UpdateSQL(r.tableName, setClauses.String(), r.pkColumn, r.dialect.Placeholder(len(vals)))

	res, execErr := r.getExecutor().ExecContext(ctx, sqlQuery, vals...)
	if execErr != nil {
		var zero T
		return zero, fmt.Errorf("update failed: %w", execErr)
	}

	rowsAffected, idErr := res.RowsAffected()
	if idErr != nil {
		var zero T
		return zero, fmt.Errorf("update successful, but failed to retrieve rows affected: %w", idErr)
	}

	if rowsAffected == 0 {
		var zero T
		return zero, sql.ErrNoRows // No row was updated
	}

	return item, nil
}

// Delete removes a record from the database by its primary key.
// It returns an error if the operation fails or if no rows were affected.
func (r *Repository[T]) Delete(ctx context.Context, id any) error {
	sqlQuery := r.dialect.DeleteSQL(r.tableName, r.pkColumn, r.dialect.Placeholder(1))

	res, err := r.getExecutor().ExecContext(ctx, sqlQuery, id)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return sql.ErrNoRows // No row was deleted
	}

	return nil
}

// List retrieves a slice of records based on the provided options.
func (r *Repository[T]) List(ctx context.Context, opts ...Option[T]) ([]T, error) {
	qb := &queryBuilder[T]{
		dialect: r.dialect,
	}
	for _, opt := range opts {
		if err := opt.apply(qb); err != nil {
			return nil, err
		}
	}

	// Always qualify column names with the table name to avoid ambiguity in joins
	selectCols := make([]string, len(r.columns))
	for i, col := range r.columns {
		selectCols[i] = r.tableName + "." + col
	}

	sql := r.dialect.SelectSQL(
		r.tableName,
		selectCols,
		strings.Join(qb.joinClauses, " "),
		strings.Join(qb.whereClauses, " AND "),
		strings.Join(qb.orderByClauses, ", "),
		qb.lockClause,
		qb.limit,
		qb.offset,
	)

	rows, err := r.getExecutor().QueryContext(ctx, sql, qb.args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []T
	for rows.Next() {
		instance, err := r.scanRow(rows)
		if err != nil {
			return nil, err
		}
		results = append(results, instance)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	// Handle eager loading if there are relations
	if len(qb.relations) > 0 {
		// We need a slice of pointers to pass to handleRelations
		parentPtrs := make([]*T, len(results))
		for i := range results {
			parentPtrs[i] = &results[i]
		}
		if err := r.handleRelations(ctx, qb, parentPtrs); err != nil {
			return nil, err
		}
	}

	return results, nil
}

// handleRelations processes the eager loading for the fetched parent entities.
func (r *Repository[T]) handleRelations(ctx context.Context, qb *queryBuilder[T], parents []*T) error {
	if len(parents) == 0 {
		return nil
	}

	for _, rel := range qb.relations {
		if err := rel.Process(ctx, parents); err != nil {
			return err
		}
	}
	return nil
}

// scanRow scans a single row from *sql.Row or *sql.Rows.
func (r *Repository[T]) scanRow(scannable interface{ Scan(...any) error }) (T, error) {
	var instance T
	val := reflect.ValueOf(&instance).Elem()
	scanDest := make([]any, len(r.columns))

	for i, colName := range r.columns {
		fieldIndex, ok := r.scanMap[colName]
		if !ok {
			return instance, fmt.Errorf("column '%s' not found in scan map for type %T", colName, instance)
		}
		scanDest[i] = val.Field(fieldIndex).Addr().Interface()
	}

	if err := scannable.Scan(scanDest...); err != nil {
		return instance, err
	}

	return instance, nil
}
